#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <pthread.h>
#include <signal.h>
#include <unistd.h>
#include <sys/wait.h>
#include <assert.h>
#include <getopt.h>
#include <ctype.h>
#include <inttypes.h>



typedef const struct msg_subscription_s {
    char * message;
} msg_subscription_t;



#define MSG_SUBSCRIBE(_msg_name, _msg) \
	__attribute__((section("msg_subscriptions"))) \
	__attribute__((aligned(1))) \
	__attribute__((used)) \
	msg_subscription_t subscription##_msg_name = { \
		.message = _msg, \
	}


static pthread_mutex_t msg_print_thread_mutex = PTHREAD_MUTEX_INITIALIZER;
static pthread_cond_t stop_program_thread_condition = PTHREAD_COND_INITIALIZER;

static volatile int stop_program_flag = 0;

static void _scoped_mutex_unlock(pthread_mutex_t ** mutex) {
    if (*mutex == NULL) {
        return;
	}
    pthread_mutex_unlock(*mutex);
    *mutex = NULL;
}

unsigned int no_mutexes = 0;

#define scoped_mutex_lock(_mutex) \
    if (!no_mutexes) { \
        int lock_err##_mutex = pthread_mutex_lock(&_mutex); \
        assert(lock_err##_mutex == 0); \
    } \
    pthread_mutex_t * __scoped_lock##_mutex __attribute__((cleanup(_scoped_mutex_unlock))) = (no_mutexes ? NULL : &_mutex);  // When not asserting we get the lock, we must not give the lock to the cleanup function.


static void sigintHandler(int signal) {
    // pthread_mutex_lock(&msg_print_thread_mutex);

    // scoped_mutex_lock(msg_print_thread_mutex);

    printf("Received SIGINT. Stopping message printing...\n");

    stop_program_flag = 1;

    // Signal waiting threads
    pthread_cond_signal(&stop_program_thread_condition);

    // pthread_mutex_unlock(&msg_print_thread_mutex);

}

unsigned int leak_memory = 0;

void usage(void) {
	printf("usage: c_example [options]\n");
	printf("\n");
	printf("Options:\n");
	printf(" -h --help\tPrint this help and exit\n");
	printf(" -v --version\tPrint program version and exit\n");
	printf(" -l --leak\tLeak memory delibiratly\n");
	printf(" -m --no-mutex\tDisable Mutexes\n");
}



static void _cleanup_str(char ** obj) {
    if (*obj == NULL) {
        return;
	}
    if (leak_memory) {
        return;
    }
    free(*obj);
    *obj = NULL;
}

// static void _cleanup_cond(pthread_cond_t ** cond) {
//     if (*cond == NULL) {
//         return;
// 	}
//     pthread_cond_destroy(*cond);
//     *cond = NULL;
// }

static void _cleanup_mutex(pthread_mutex_t ** mutex) {
    if (*mutex == NULL) {
        return;
	}
    pthread_mutex_destroy(*mutex);
    *mutex = NULL;
}

// void message_thread_atexit(int * retval) {
//     pthread_exit(retval);
// }

void *message_print_thread(void *_message_args) {
    msg_subscription_t * message_args = (msg_subscription_t*)_message_args;
    const char * print_message = message_args->message;
    assert(print_message);

    //int retval __attribute__((cleanup(message_thread_atexit))) = 0;

    while (1) {
        usleep(100000);
        {
            scoped_mutex_lock(msg_print_thread_mutex);
            
            if (stop_program_flag) {
                
                return NULL;
            }

            char * msg_dup __attribute__((cleanup(_cleanup_str))) = strdup(print_message);
            if (!msg_dup) {
                continue;
            }

            const unsigned int msg_len = strlen(msg_dup);
            for (size_t i = 0; i < msg_len; i++) {
                printf("%c", msg_dup[i]);
                fflush(stdout);
                usleep(100000);
            }
            printf("\n");
            
        }
    }
}

MSG_SUBSCRIBE(1, "cool");
MSG_SUBSCRIBE(2, "awesome");

int main(int argc, char **argv) {

    int option;
    struct option long_options[] = {
        {"help", no_argument, 0, 'h'},
        {"version", no_argument, 0, 'v'},
        {"leak", required_argument, 0, 'l'},
        {"no-mutex", required_argument, 0, 'm'},
        {0, 0, 0, 0} // Indicates the end of options
    };
    
    unsigned should_exit = 0;

    while ((option = getopt_long(argc, argv, "hvlm", long_options, NULL)) != -1) {
        switch (option) {
            case 'h':
                usage();
                should_exit = 1;
                break;
            case 'v':
                /* version_string is generated by meson.build with vcs_tag() */
                extern const char *version_string;
                printf("Version %s\n", version_string);
                should_exit = 1;
                break;
            case 'l':
                printf("Enabling memory leaks\n");
                leak_memory = 1;
                break;
            case 'm':
                printf("Disabling mutexes\n");
                no_mutexes = 1;
                break;
            case '?':
                // Error handling goes here
                 if (isprint(optopt)) {
                    fprintf(stderr, "Unknown option `-%c'.\n", optopt);
                } else {
                    fprintf(stderr, "Unknown option character `\\x%x'.\n", optopt);
                }
                exit(-1);
                break;
            default:
                break;
        }
    }

    if (should_exit) {
        exit(0);
    }

#if 1
    if (signal(SIGINT, sigintHandler) == SIG_ERR) {
        exit(-2);
    }
#else  /* Using sigaction is supposedly better */
    struct sigaction sigterm_action;
    memset(&sigterm_action, 0, sizeof(sigterm_action));
    sigterm_action.sa_handler = &sigintHandler;
    sigterm_action.sa_flags = 0;
#endif

    pthread_mutex_init(&msg_print_thread_mutex, NULL);
    // pthread_cond_init(&stop_program_thread_condition, NULL);
    pthread_mutex_t * _mutex_cleanup_symbol __attribute__((cleanup(_cleanup_mutex))) = &msg_print_thread_mutex;
    // pthread_cond_t * _cond_cleanup_symbol __attribute__((cleanup(_cleanup_cond))) = &stop_program_thread_condition;

    /**
	 * GNU Linker symbols. These will be autogenerate by GCC when using
	 * __attribute__((section("sim_subscriptions"))
	 */
	__attribute__((weak)) extern msg_subscription_t __start_msg_subscriptions;
	__attribute__((weak)) extern msg_subscription_t __stop_msg_subscriptions;

    const unsigned int num_messages = (unsigned int)(&__stop_msg_subscriptions - &__start_msg_subscriptions);
    pthread_t message_thread_pool[num_messages];
    memset(message_thread_pool, 0, sizeof(pthread_t)*num_messages);

    /* For some reason this 'if' is needed, even though the for-loop condition should be sufficient.
        It can't be replaced with a guard clause, as we must allow the other priorities to run.*/
    unsigned int i = -1;
    if (&__start_msg_subscriptions != &__stop_msg_subscriptions && &__start_msg_subscriptions != NULL) {
        for (msg_subscription_t * msg_subscription = &__start_msg_subscriptions; msg_subscription < &__stop_msg_subscriptions; msg_subscription++) {
            i++;
            assert(i<=num_messages-1);
            if ((pthread_create(&message_thread_pool[i], NULL, message_print_thread, (void*)msg_subscription)) != 0) {
                fprintf(stderr, "Failed to create house thread, number %d\n", i);
                exit(9);
            }
        }
    }


    // TODO Kevin: We would need to create a separate mutex here
    // pthread_cond_wait(&stop_program_thread_condition, &msg_print_thread_mutex);
    // {
    //     //scoped_mutex_lock(msg_print_thread_mutex);
    //     assert(stop_program_flag);
    // }
    
    // Wait for all threads to finish
    for (int i = 0; i < num_messages; ++i) {
        assert(message_thread_pool[i]);
        pthread_join(message_thread_pool[i], NULL);
        
    }

    return 0;

}
