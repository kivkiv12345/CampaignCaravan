// Mostly copied from: https://github.com/kivkiv12345/ckafprod

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <pthread.h>
#include <signal.h>
#include <unistd.h>
#include <sys/wait.h>
#include <assert.h>
#include <getopt.h>
#include <ctype.h>
#include <inttypes.h>



typedef const struct msg_subscription_s {
    char * message;
} msg_subscription_t;

#define MSG_SUBSCRIBE(_msg_name, _msg) \
	__attribute__((section("msg_subscriptions"))) \
	msg_subscription_t subscription##_msg_name = { \
		.message = _msg, \
	}

MSG_SUBSCRIBE(1, "cool");
MSG_SUBSCRIBE(2, "awesome");
MSG_SUBSCRIBE(3, "Hej Censor");
MSG_SUBSCRIBE(4, "Hej Eksaminator");


static pthread_mutex_t msg_print_thread_mutex = PTHREAD_MUTEX_INITIALIZER;
static pthread_cond_t stop_program_thread_condition = PTHREAD_COND_INITIALIZER;

static volatile int stop_program_flag = 0;

static void _scoped_mutex_unlock(pthread_mutex_t ** mutex) {
    if (*mutex == NULL) {
        return;
	}
    pthread_mutex_unlock(*mutex);
    *mutex = NULL;
}

unsigned int no_mutexes = 0;

#define scoped_mutex_lock(_mutex) \
    if (!no_mutexes) { \
        int lock_err##_mutex = pthread_mutex_lock(&_mutex); \
        assert(lock_err##_mutex == 0); \
    } \
    pthread_mutex_t * __scoped_lock##_mutex __attribute__((cleanup(_scoped_mutex_unlock))) = (no_mutexes ? NULL : &_mutex);  // When not asserting we get the lock, we must not give the lock to the cleanup function.


static void sigintHandler(int signal) {

    //scoped_mutex_lock(msg_print_thread_mutex);

    printf("Received SIGINT. Stopping...\n");

    stop_program_flag = 1;

    // Signal waiting threads
    pthread_cond_signal(&stop_program_thread_condition);


}

unsigned int leak_memory = 0;

void usage(void) {
	printf("usage: c_example [options]\n");
	printf("\n");
	printf("Options:\n");
	printf(" -h --help\tPrint this help and exit\n");
	printf(" -v --version\tPrint program version and exit\n");
	printf(" -l --leak\tLeak memory delibiratly\n");
	printf(" -m --no-mutex\tDisable Mutexes\n");
}

static void _cleanup_str(char ** obj) {
    if (*obj == NULL) {
        return;
	}
    if (leak_memory) {
        return;
    }
    free(*obj);
    *obj = NULL;
}

static void _cleanup_mutex(pthread_mutex_t ** mutex) {
    if (*mutex == NULL) {
        return;
	}
    pthread_mutex_destroy(*mutex);
    *mutex = NULL;
}

void *message_print_thread(void *_message_args) {
    msg_subscription_t * message_args = (msg_subscription_t*)_message_args;
    const char * print_message = message_args->message;
    assert(print_message);

    while (1) {
        usleep(100000);
        {
            scoped_mutex_lock(msg_print_thread_mutex);
            
            if (stop_program_flag) {
                
                return NULL;
            }

            char * msg_dup __attribute__((cleanup(_cleanup_str))) = strdup(print_message);
            if (!msg_dup) {
                continue;
            }

            const unsigned int msg_len = strlen(msg_dup);
            for (size_t i = 0; i < msg_len; i++) {
                printf("%c", msg_dup[i]);
                fflush(stdout);
                usleep(100000);
            }
            printf("\n");
            
        }
    }
}

#if 0
#if 0
static void cleanup_print(char ** msg) {
    printf(*msg);
}
#endif


static void heap_print(void) {
    #define ONE_MB 1024*1024
    unsigned int *arr = malloc(ONE_MB*9 * sizeof(unsigned int));
    arr[0] = 0;
    printf("%d\n", arr[0]);
    free(arr);
}

int main(int argc, char **argv) {

    heap_print();
    exit(0);

#if 0
    unsigned last = 0;
    for (unsigned *i = malloc(sizeof(unsigned)); i != NULL; i = malloc(sizeof(unsigned))) {
        *i = last;
        usleep(1000);
        *i += 1;
        printf("%d\n", *i);
        last = *i;
        free(i);
    }
#endif


#if 0
    {
        printf("1\n");
        char * msg1 __attribute__((cleanup(cleanup_print))) = "close connection\n";
        char * msg2 __attribute__((cleanup(cleanup_print))) = "free packet\n";
        printf("3\n");
    }

    exit(0);
#endif

#else
int main(int argc, char **argv) {
#endif

    int option;
    struct option long_options[] = {
        {"help", no_argument, 0, 'h'},
        {"version", no_argument, 0, 'v'},
        {"leak", required_argument, 0, 'l'},
        {"no-mutex", required_argument, 0, 'm'},
        {0, 0, 0, 0} // Indicates the end of options
    };
    
    unsigned should_exit = 0;

    while ((option = getopt_long(argc, argv, "hvlm", long_options, NULL)) != -1) {
        switch (option) {
            case 'h':
                usage();
                should_exit = 1;
                break;
            case 'v':
                /* version_string is generated by meson.build with vcs_tag() */
                extern const char *version_string;
                printf("Version %s\n", version_string);
                should_exit = 1;
                break;
            case 'l':
                printf("Enabling memory leaks\n");
                leak_memory = 1;
                break;
            case 'm':
                printf("Disabling mutexes\n");
                no_mutexes = 1;
                break;
            case '?':
                // Error handling goes here
                 if (isprint(optopt)) {
                    fprintf(stderr, "Unknown option `-%c'.\n", optopt);
                } else {
                    fprintf(stderr, "Unknown option character `\\x%x'.\n", optopt);
                }
                exit(-1);
                break;
            default:
                break;
        }
    }

    if (should_exit) {
        exit(0);
    }

    if (signal(SIGINT, sigintHandler) == SIG_ERR) {
        exit(-2);
    }

    pthread_mutex_init(&msg_print_thread_mutex, NULL);
    pthread_mutex_t * _mutex_cleanup_symbol __attribute__((cleanup(_cleanup_mutex))) = &msg_print_thread_mutex;

    /**
	 * GNU Linker symbols. These will be autogenerate by GCC when using
	 * __attribute__((section("msg_subscriptions"))
	 */
	__attribute__((weak)) extern msg_subscription_t __start_msg_subscriptions;
	__attribute__((weak)) extern msg_subscription_t __stop_msg_subscriptions;

    const unsigned int num_messages = (unsigned int)(&__stop_msg_subscriptions - &__start_msg_subscriptions);
    pthread_t message_thread_pool[num_messages];
    memset(message_thread_pool, 0, sizeof(pthread_t)*num_messages);

    if (&__start_msg_subscriptions == NULL || &__stop_msg_subscriptions == NULL) {
        printf("No message subscriptions to print\n");
        return 0;
    }

    unsigned int i = -1;
    for (msg_subscription_t * msg_subscription = &__start_msg_subscriptions; msg_subscription < &__stop_msg_subscriptions; msg_subscription++) {
        i++;
        assert(i<=num_messages-1);
        if ((pthread_create(&message_thread_pool[i], NULL, message_print_thread, (void*)msg_subscription)) != 0) {
            fprintf(stderr, "Failed to create message thread, number %d\n", i);
            return -1;
        }
    }
    
    // Wait for all threads to finish
    for (int i = 0; i < num_messages; ++i) {
        assert(message_thread_pool[i]);
        pthread_join(message_thread_pool[i], NULL);
        
    }

    return 0;

}
